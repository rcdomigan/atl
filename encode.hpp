#ifndef ATL_ENCODE_HH
#define ATL_ENCODE_HH
/**
 * @file /home/ryan/programming/atl/encode.hpp
 * @author Ryan Domigan <ryan_domigan@sutdents@uml.edu>
 * Created on Aug 06, 2013
 */

#include <functional>
#include <map>

#include "./print.hpp"
#include "./infer.hpp"
#include "./helpers.hpp"
#include "./ffi.hpp"
#include "./environment.hpp"

namespace atl {
    // takes an AST as generated by the basic parser and encodes it to an exicutable form
    class EncodeAST {
	friend class EvaluateAST;
	GC &_gc;

	lexical::Map &_env, *_top;
	typedef typename GC::DynamicVector Stack;

	template<class IRange>
	void define_macro(Stack& stack, const IRange& ast) {
	    auto &formals = unwrap<Ast>(ast[1]);
	    auto &body = unwrap<Ast>(ast[2]);

	    stack.push_back(aimm<DefineMacro>());
	    stack.push_back(
	        _top->predefine(unwrap<string>(formals[0]))
	    );
	    lambda(stack, slice(formals, 1), body);
	}

	template<class Range>
	void define(Stack& stack, const Range& ast) {
	    stack.push_back(aimm<Define>());
	    stack.push_back(_top->predefine(unwrap<string>(ast[1])));
	    auto value = ast[2];
	    if(is<Ast>(value))
		encode(stack, unwrap<Ast>(value));
	    else
		stack.push_back(value);
	}

	template<class FRange, class BRange>
	void lambda(Stack& stack, const FRange& formals, const BRange& body) {
	    using namespace printer;
	    lexical::Map local(_top);
	    _top = &local;

	    Procedure *cc = _gc.make<Procedure*>(formals.size());
	    stack.push_back(wrap(cc));

	    size_t i = 0;
	    for(auto &vv : formals)
		local.define(unwrap<string>(vv), wrap(&cc->_parameters[i++]));

	    auto encoded_body = _gc.dynamic_vector();
	    encode(*encoded_body, body);
	    cout << "Body input: "
		 << printer::range(body)
		 << endl;

	    // TODO: Deal with non AST bodies
	    cc->_body = *encoded_body->begin();

	    cout << "Encoded body: " << printer::any(cc->_body)
		 << endl;

	    cout << "Encoded body: " << printer::range(*encoded_body)
		 << endl;

	    _top = local._prev;
	}


	Any look_up(const string& str) {
	    lexical::Map::iterator i = _top->find(str);
	    if (i != _top->end()) {
		return i->second;
	    } else
		return _top->predefine(str);
	}

	template<class Range>
	void encode(Stack& stack, const Range &ast) {
	    auto frame = stack.push_seq<Ast>();
	    Any input = ast[0];
	find_form:
	    switch (input._tag) {
	    case tag<Symbol>::value:
		input = look_up(unwrap<string>(input));
		if( is<Undefined>(input) ) {
		    stack.push_back(input);
		    unwrap<Undefined>(input)._backtrack.push_back(stack.end() - 1);
		    break;
		} else
		    goto find_form;
	    case tag<Define>::value:
		define(stack, ast);
		frame->end_at(stack.end());
		return;
	    case tag<DefineMacro>::value:
		define_macro(stack, ast);
		frame->end_at(stack.end());
		return;
	    case tag<Quote>::value: {
		auto rval = reinterpret_cast<Any*>(frame);
		*rval = ast[1];
		stack._end = rval + 1;
		return;
	    }
	    case tag<Lambda>::value: {
		if( !is<Ast>( ast[1]) ) throw string("Bad lambda form");
		if( !is<Ast>( ast[2]) ) throw string("TODO: Non Ast lambda body");

		auto& formals = unwrap<Ast>(ast[1]);
		auto& body = unwrap<Ast>(ast[2]);

		// Get rid of the nested Ast.
		stack.pop_back(2);
		lambda(stack, formals, body);
		return;
	    }
	    case tag<Ast>::value:
		encode(stack, unwrap<Ast>(input));
		break;
	    default:
		stack.push_back(input);
		break;
	    }

	    for(auto& vv : slice(ast, 1)) {
		switch(vv._tag) {
		case tag<Ast>::value:
		    encode(stack, unwrap<Ast>(vv));
		    break;
		case tag<Symbol>::value: {
		    auto value = look_up(unwrap<std::string>(vv));
		    if(is<Undefined>(value))
			unwrap<Undefined>(value)._backtrack.push_back(stack.end());
		    stack.push_back(value);
		    break;
		}
		default:
		    stack.push_back(vv);
		}}
	    frame->end_at(stack.end()); }

    public:
	void define(const char* name, Any a) { _env.define(name,a); }

	void function(const char* name, PrimitiveRecursive *fn) {
	    _env.define(name, Any(tag<PrimitiveRecursive>::value, fn)); }

	template<class T>
	void wrap_fn(const char* name, std::function<T>&& fn) {
	    function(name, WrapFn<T>::a(std::forward<const std::function<T> >(fn), &_gc, name) ); }

	EncodeAST(Environment& env, GC &gc) : _gc(gc), _env(env.toplevel) {
	    _top = &_env;

	    init_types();		/* initialize types */

	    _gc.mark_callback( [this](GC &gc) {
		    for( lexical::Map *m = _top; m; m = m->_prev ) {
			for(auto vv : m->_local)
			    gc.mark( vv.second );
		    }
		});
	}

	Any any(Any vv) {
	    switch(vv._tag) {
	    case tag<Ast>::value: {
		auto stack = _gc.dynamic_vector();
		encode(*stack, unwrap<Ast>(vv));
		return *stack->begin();
	    }
	    case tag<Symbol>::value: {
		return look_up(unwrap<string>(vv));
	    }
	    default:
		return vv;
	    }}
    };
}

#endif
